#ifndef SPECTRACO_HPP
#define SPECTRACO_HPP

class SpectraCo
{
public:

  SpectraCo() = default;

  SpectraCo(TH1* root_spectra)
  {
    load(root_spectra);
  }

  SpectraCo(SpectraCo const & other) : 
    m_spectra   (other.m_spectra),
    m_name      (other.m_name),
    m_size      (other.m_size),
    m_integral  (other.m_integral),
    m_min_value (other.m_min_value),
    m_max_value (other.m_max_value)
  {
    // throw_error("SpectraCo::SpectraCo(SpectraCo const & other) : function is not working !");
  }

  SpectraCo(SpectraCo const & other, Recalibration const & recal) : 
    m_spectra   (other.m_spectra),
    m_name      (other.m_name),
    m_size      (other.m_size),
    m_integral  (other.m_integral),
    m_min_value (other.m_min_value),
    m_max_value (other.m_max_value)
  {
    // throw_error("SpectraCo::SpectraCo(SpectraCo const & other) : function is not working !");
    this -> recalibrate(recal);
  }

  SpectraCo(std::vector<double> const & data) :
    m_spectra(data),
    m_size(data.size()),
    m_min_value(0),
    m_max_value(m_size)
  {
  }

  SpectraCo& operator=(TH1* root_spectra)
  {
    load(root_spectra);
    return *this;
  }

  void load(TH1* root_spectra)
  {
    if (root_spectra->IsA()->InheritsFrom(TH2::Class()) || root_spectra->IsA()->InheritsFrom(TH3::Class()))
    {
      throw_error("In SpectraAlignator::SpectraAlignator(TH1* root_spectra) : root_spectra is a TH2 or TH3 !!");
    }

    m_name = root_spectra->GetName();
    m_title = root_spectra->GetTitle();
    
    m_integral = root_spectra->Integral();
    m_size = root_spectra -> GetXaxis() -> GetNbins();
    m_min_value = root_spectra -> GetXaxis() -> GetBinLowEdge(0)+1;
    m_max_value = root_spectra -> GetXaxis() -> GetBinLowEdge(m_size)+1;

    m_spectra.resize(m_size);
    for (int bin = 0; bin<m_size; bin++) m_spectra[bin] = root_spectra->GetBinContent(bin);
  }

  std::vector<double> const & derivative() {return m_derivative;}
  std::vector<double> const & derivate(int const & smooth = 1)
  {
    m_derivative.resize(m_size);
    double low_sum = 0.0;
    double up_sum = 0.0;
    int lower_bin = 0;
    int upper_bin = m_size;
    for (int bin = 0; bin<m_size; bin++)
    {
      // First, sum the value of all the bins on the left :
      low_sum = 0.0;
      for (int bin_low = ((lower_bin = bin-smooth) < 1) ? 0 : lower_bin; bin_low<bin; bin_low++)
      {
        low_sum+=m_spectra[bin_low];
      }

      // Second, sum the value of all the bins on the right :
      up_sum = 0.0;
      upper_bin = ((upper_bin = bin+smooth)<(m_size+1)) ? upper_bin : m_size;
      for (int bin_up = bin; bin_up<upper_bin; bin_up++)
      {
        up_sum+=m_spectra[bin_up];
      }

      // Calculate the derivative : (sum_left - sum_right) / (x_right - x_left)
      m_derivative[bin] = (low_sum-up_sum)/(2*smooth);
    }
    // if (smooth<1) throw_error("in SpectraCo::derivate(int const & smooth = 1) : smooth < 1, can't do that !!");
    // if (smooth>3) throw_error("in SpectraCo::derivate(int const & smooth = 1) : smooth > 3, can't do that !!");
    // if (smooth == 1)
    // {
    //   m_derivative[0] = m_spectra[1]-m_spectra[0];
    //   for (int bin = 1; bin<m_size-1; bin++) m_derivative[bin] = (m_spectra[bin+1]-m_spectra[bin-1])/2;
    //   m_derivative[m_size] = m_spectra[m_size]-m_spectra[m_size-1];
    // }
    // else if (smooth == 2)
    // {
    //   m_derivative[0] = m_spectra[1]-m_spectra[0]/2;
    //   m_derivative[1] = m_spectra[2]-m_spectra[0]/2;
    //   for (int bin = 2; bin<m_size-1; bin++) m_derivative[bin] = (m_spectra[bin+2]+m_spectra[bin+1]-m_spectra[bin-1]-m_spectra[bin-2])/4;
    //   m_derivative[m_size-1] = m_spectra[m_size]-m_spectra[m_size-2]/2;
    //   m_derivative[m_size] = m_spectra[m_size]-m_spectra[m_size-1]/2;
    // }
    // else if (smooth == 3)
    // {
    //   m_derivative[0] = m_spectra[1]-m_spectra[0]/2;
    //   m_derivative[1] = m_spectra[2]-m_spectra[0]/2;
    //   m_derivative[2] = m_spectra[3]-m_spectra[1]/2;
    //   for (int bin = 3; bin<m_size-1; bin++) m_derivative[bin] = (m_spectra[bin+3]+m_spectra[bin+2]+m_spectra[bin+1] - m_spectra[bin-1]-m_spectra[bin-2]-m_spectra[bin-3])/6;
    //   m_derivative[m_size-2] = m_spectra[m_size-1]-m_spectra[m_size-3]/2;
    //   m_derivative[m_size-1] = m_spectra[m_size]-m_spectra[m_size-2]/2;
    //   m_derivative[m_size] = m_spectra[m_size]-m_spectra[m_size-1]/2;
    // }
    return m_derivative;
  }

  std::vector<double> const & derivative2() {return m_derivative2;}
  std::vector<double> const & derivate2(int const & smooth = 1)
  {
    derivate(smooth);
    m_derivative2.resize(m_size);
    double low_sum = 0.0;
    double up_sum = 0.0;
    int lower_bin = 0;
    int upper_bin = m_size;
    for (int bin = 0; bin<m_size; bin++)
    {
      // First, sum the value of all the bins on the left :
      low_sum = 0.0;
      for (int bin_low = ((lower_bin = bin-smooth) < 1) ? 0 : lower_bin; bin_low<bin; bin_low++)
      {
        low_sum+=m_derivative[bin_low];
      }

      // Second, sum the value of all the bins on the right :
      up_sum = 0.0;
      upper_bin = ((upper_bin = bin+smooth)<(m_size+1)) ? upper_bin : m_size;
      for (int bin_up = bin; bin_up<upper_bin; bin_up++)
      {
        up_sum+=m_derivative[bin_up];
      }

      // Calculate the derivative : (sum_left - sum_right) / (x_right - x_left)
      m_derivative2[bin] = (low_sum-up_sum)/(2*smooth);
    }
    // m_derivative2[0] = m_derivative[1]-m_derivative[0];
    // for (int bin = 1; bin<m_size-1; bin++)
    // {
    //   m_derivative2[bin] = (m_derivative[bin+1]-m_derivative[bin-1]);
    // }
    // m_derivative2[m_size] = m_derivative[m_size]-m_derivative[m_size-1];
    return m_derivative2;
  }

  void setMinValue( double const & _min_value) {m_min_value = _min_value;}
  void setMaxValue( double const & _max_value) {m_max_value = _max_value;}

  auto name(std::string const & name) {return (m_name = name);}
  auto title(std::string const & title) {return (m_title = title);}

  auto const & name() const {return m_name;}
  auto const & title() const {return m_title;}
  auto const & size() const {return m_size;}
  auto const & integral() const {return m_integral;}
  auto const & minValue() const {return m_min_value;}
  auto const & maxValue() const {return m_max_value;}

  auto & get() {return m_spectra;}
  auto const & get() const {return m_spectra;}
  auto const & lastBin()  const {return m_spectra.back();}
  auto const & back()  const {return m_spectra.back();}

  TH1D* createTH1D(std::string newName = "", std::string newTitle = "")
  {
    if (newName == "") newName = m_name;
    if (newTitle == "") newTitle = m_title;
    TH1D* out = new TH1D(m_name.c_str(), m_title.c_str(), m_size, this->minValue(), this->maxValue());
    for (int bin = 0; bin<m_size; bin++) out->SetBinContent(bin, m_spectra[bin]);
    return out;
  }

  TH1F* createTH1F(std::string newName = "", std::string newTitle = "")
  {
    if (newName == "") newName = m_name;
    if (newTitle == "") newTitle = m_title;
    TH1F* out = new TH1F(newName.c_str(), newTitle.c_str(), m_size, this->minValue(), this->maxValue());
    for (int bin = 0; bin<m_size; bin++) out->SetBinContent(bin, m_spectra[bin]);
    return out;
  }

  auto const & get(int const & bin) const {return m_spectra[bin];}
  auto const & operator[] (int const & bin) const {return m_spectra[bin];}
  auto & operator[] (int const & bin) {return m_spectra[bin];}
  double operator[] (double const & bin) const
  {
    int i = static_cast<int>(bin); //bin_i
    if (i<0) i = 0;
    else if (i > (m_size-1)) i = m_size;
    double const & a = m_spectra[i+1] - m_spectra[i];// a  =  y_i+1 - y_i
    double const & b = m_spectra[i] - a*i;           // b  =  y_i - a*bin_i
    return a*bin+b;
  }
  
  SpectraCo operator+(SpectraCo const & other)
  {
    if (other.m_size != m_size) throw_error("in operator+(SpectraCo const & other) : other size is different from that of this spectra");
    SpectraCo spectra(*this);
    for (int bin = 0; bin<m_size; bin++) spectra[bin] += other[bin];
    spectra.name(spectra.name()+" + "+other.name());
    spectra.title(spectra.title()+" + "+other.title());
    return spectra;
  }

  SpectraCo operator-(SpectraCo const & other)
  {
    if (other.m_size != m_size) throw_error("in operator+(SpectraCo const & other) : other size is different from that of this spectra");
    SpectraCo spectra(*this);
    for (int bin = 0; bin<m_size; bin++) spectra[bin] -= other[bin];
    spectra.name(spectra.name()+" - "+other.name());
    spectra.title(spectra.title()+" - "+other.title());
    return spectra;
  }

  /// @brief wrapper around operator[]
  double interpolate(double const & bin) const {return (*this)[bin];} 

  void recalibrate(Recalibration const & recal)
  {
    std::vector<double> newSpectra(m_size);
    for (int bin = 0; bin<m_size; bin++)
    {
      auto const & new_bin = recal.calculate(bin);
      newSpectra[bin] = interpolate(new_bin);
    }
    m_spectra = newSpectra;
  }

  void Draw(const char* param = "")
  {
    TH1F* drawer = createTH1F();
    drawer->Draw(param);
    // pauseCo();
  }

private:
  std::vector<double> m_spectra;
  std::vector<double> m_derivative;
  std::vector<double> m_derivative2; // Second derivative

  std::string m_name = "Unnamed";
  std::string m_title = "Untitled";

  int m_size = -1;
  int m_integral = 0;
  int m_min_value = 0;
  int m_max_value = 0;
};

#endif //SPECTRACO_HPP