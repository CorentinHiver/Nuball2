.TH "Event" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Event \- \fBEvent\fP used for reading and writting event, event building and trigger\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Event\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "auto & \fBadc\fP (int const &hit_i)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBEvent\fP ()"
.br
.ti -1c
.RI "\fBEvent\fP (\fBEvent\fP const &event)"
.br
.ti -1c
.RI "\fBEvent\fP (\fBHit\fP const &hit)"
.br
.ti -1c
.RI "\fBEvent\fP (TTree *tree)"
.br
.ti -1c
.RI "\fBEvent\fP (TTree *tree, std::string const &options)"
.br
.ti -1c
.RI "bool \fBisCalibrated\fP () const"
.br
.ti -1c
.RI "bool \fBisEmpty\fP () const"
.br
.ti -1c
.RI "bool \fBisSingle\fP () const"
.br
.ti -1c
.RI "auto & \fBlabel\fP (int const &hit_i)"
.br
.ti -1c
.RI "\fBsize_t\fP const  & \fBmaxSize\fP () const"
.br
.ti -1c
.RI "auto & \fBnrj\fP (int const &hit_i)"
.br
.ti -1c
.RI "auto & \fBnrj2\fP (int const &hit_i)"
.br
.ti -1c
.RI "\fBEvent\fP & \fBoperator=\fP (\fBEvent\fP const &evt)"
.br
.ti -1c
.RI "\fBEvent\fP & \fBoperator=\fP (\fBHit\fP const &hit)"
.br
.ti -1c
.RI "\fBHit\fP \fBoperator[]\fP (int const &hit_i)"
.br
.ti -1c
.RI "auto & \fBpileup\fP (int const &hit_i)"
.br
.ti -1c
.RI "void \fBPrint\fP () const"
.br
.ti -1c
.RI "void \fBpush_back\fP (\fBHit\fP const &hit)"
.br
.ti -1c
.RI "void \fBpush_front\fP (\fBHit\fP const &hit)"
.br
.RI "Sometimes, we want to select pre-prompt events\&. In such case, we have to put in in front of the others\&. "
.ti -1c
.RI "auto & \fBqdc2\fP (int const &hit_i)"
.br
.ti -1c
.RI "void \fBreading\fP (TTree *tree)"
.br
.RI "Automatically set branches based on the presence or not of branches in the root tree\&. Reserved for 'Nuball2' type of trees\&. "
.ti -1c
.RI "void \fBreading\fP (TTree *tree, std::string const &options)"
.br
.ti -1c
.RI "void \fBsetT0\fP (\fBTimestamp\fP const &timestamp)"
.br
.ti -1c
.RI "\fBsize_t\fP \fBsize\fP () const"
.br
.ti -1c
.RI "auto & \fBtime\fP (int const &hit_i)"
.br
.ti -1c
.RI "auto & \fBtime2\fP (int const &hit_i)"
.br
.ti -1c
.RI "\fBTime_ns\fP \fBtime_ns\fP (int const &i) const"
.br
.ti -1c
.RI "void \fBtimeShift\fP (\fBTime\fP const &shift)"
.br
.ti -1c
.RI "void \fBtimeShift_ns\fP (double const &shift)"
.br
.ti -1c
.RI "void \fBwritting\fP (TTree *tree, std::string const &options='lstTeEqQ')"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBADC\fP \fBadcs\fP [255] = {0}"
.br
.ti -1c
.RI "\fBLabel\fP \fBlabels\fP [255] = {0}"
.br
.ti -1c
.RI "int \fBmult\fP = 0"
.br
.ti -1c
.RI "\fBNRJ\fP \fBnrj2s\fP [255] = {0}"
.br
.ti -1c
.RI "\fBNRJ\fP \fBnrjs\fP [255] = {0}"
.br
.ti -1c
.RI "\fBPileup\fP \fBpileups\fP [255] = {0}"
.br
.ti -1c
.RI "\fBADC\fP \fBqdc2s\fP [255] = {0}"
.br
.ti -1c
.RI "\fBIOptions\fP \fBread\fP"
.br
.ti -1c
.RI "\fBTimestamp\fP \fBstamp\fP = 0ull"
.br
.ti -1c
.RI "\fBTime_ns\fP \fBtime2s\fP [255] = {0}"
.br
.ti -1c
.RI "\fBTime\fP \fBtimes\fP [255] = {0}"
.br
.ti -1c
.RI "\fBIOptions\fP \fBwrite\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBisReading\fP = false"
.br
.ti -1c
.RI "bool \fBisWritting\fP = false"
.br
.ti -1c
.RI "\fBsize_t\fP \fBm_maxSize\fP = 255"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBEvent\fP used for reading and writting event, event building and trigger\&. 

An \fBEvent\fP is in principle a collection of Hits\&. However, in order to be an efficient interface with ROOT TTree, in practice it consist of a collections of arrays that stores values of a specific branch\&.
.PP
The following are public members (i\&.e\&. you can call it directly with \fBEvent\fP::[array_name]) 
.PP
.nf
   int mult = 0;                  Number of hits currently stored in the event.
   Timestamp stamp = 0ull;         Absolute timestamp of the whole event
   Label   labels  [255] = {0};    Labels of the hits
   Time    times   [255] = {0};    Time in ps (Long64_t) relative to the first hit
   Time_ns time2s  [255] = {0};    Time in ns (float) relative either to the first hit or to the pulse
   ADC     adcs    [255] = {0};    Uncalibrated ADC value of the energy
   NRJ     nrjs    [255] = {0};    Calibrated (or simply gain matched) energy value in keV
   ADC     qdc2s   [255] = {0};    Uncalibrated QDC value of the energy measured in the second time gate for QDC2 channels
   NRJ     nrj2s   [255] = {0};    Calibrated (or simply gain matched) energy value in keV. By default, the energy calibration is the same as the nrj so that the ratio remains the same
   Pileup  pileups [255] = {0};    Pileup or saturation bit

.fi
.PP
 Format of a branch inside the root tree : 
.PP
.nf
   "array[mult]/type"

.fi
.PP
 Only the two first members are not arrays because they are true for the entire event\&.
.PP
To read any Nuball2-like TTree : 
.PP
.nf
   // Loads the TTree or TChain ...
   Event event;
   event.reading(ttree);

.fi
.PP
 If you are only interested in a few branches, you can choose them by adding an option : 
.PP
.nf
   event.reading(ttree, "lst"); // Reads only the multiplicity, label, timestamp and relatative time.

.fi
.PP
 Note the multiplicity will always be activated, because it is mandatory to read the root file\&.
.PP
A list of all the options available so far : 
.PP
.nf
   l : label  label                 ushort
   s : stamp  absolute timestamp ps ULong64_t
   t : time   relative timestamp ps Long64_t
   T : time2  relative timestamp ns float
   e : adc    energy in ADC         int
   E : nrj    energy in keV         float
   q : qdc2   energy qdc2 in ADC    float
   Q : nrj2   energy qdc2 in keV    float
   p : pileup pilepup               bool

.fi
.PP
 You can access the readed branches via the \fBEvent::read\fP member (see the ReadIO struct definition)
.PP
You can use this class to write in another root tree\&. To do so, use the \fBEvent::writting\fP method : 
.PP
.nf
   event.writting(outTree, "lstEQ"); Will write the multiplicity, timestamp, relative time and calibrated energy and QDC2

.fi
.PP
 You can as well access the written branches via the \fBEvent::write\fP member (see the WriteIO struct definition)
.PP
Interface with \fBHit\fP class :
.PP
You can add Hits to an event using the \fBEvent::push_back\fP or \fBEvent::push_front\fP methods : 
.PP
.nf
   event.push_back(hit);

   event.push_front(hit);

.fi
.PP
 When the event is complete (e\&.g\&. in an event builder), you can for instance write it down or analyse it, then call \fBEvent::clear()\fP to empty it\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Event::Event ()\fC [inline]\fP"

.SS "Event::Event (\fBHit\fP const & hit)\fC [inline]\fP"

.SS "Event::Event (\fBEvent\fP const & event)\fC [inline]\fP"

.SS "Event::Event (TTree * tree)\fC [inline]\fP"

.SS "Event::Event (TTree * tree, std::string const & options)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "auto& Event::adc (int const & hit_i)\fC [inline]\fP"

.SS "void Event::clear ()\fC [inline]\fP"

.SS "bool Event::isCalibrated () const\fC [inline]\fP"

.SS "bool Event::isEmpty () const\fC [inline]\fP"

.SS "bool Event::isSingle () const\fC [inline]\fP"

.SS "auto& Event::label (int const & hit_i)\fC [inline]\fP"

.SS "\fBsize_t\fP const& Event::maxSize () const\fC [inline]\fP"

.SS "auto& Event::nrj (int const & hit_i)\fC [inline]\fP"

.SS "auto& Event::nrj2 (int const & hit_i)\fC [inline]\fP"

.SS "\fBEvent\fP & Event::operator= (\fBEvent\fP const & evt)\fC [inline]\fP"

.SS "\fBEvent\fP & Event::operator= (\fBHit\fP const & hit)\fC [inline]\fP"

.SS "\fBHit\fP Event::operator[] (int const & hit_i)"

.SS "auto& Event::pileup (int const & hit_i)\fC [inline]\fP"

.SS "void Event::Print () const\fC [inline]\fP"

.SS "void Event::push_back (\fBHit\fP const & hit)\fC [inline]\fP"

.SS "void Event::push_front (\fBHit\fP const & hit)\fC [inline]\fP"

.PP
Sometimes, we want to select pre-prompt events\&. In such case, we have to put in in front of the others\&. About the timestamp of the event, we keep the same as this additionnal event is located before the first hit that really represents the '0' of the event 
.SS "auto& Event::qdc2 (int const & hit_i)\fC [inline]\fP"

.SS "void Event::reading (TTree * tree)\fC [inline]\fP"

.PP
Automatically set branches based on the presence or not of branches in the root tree\&. Reserved for 'Nuball2' type of trees\&. 
.SS "void Event::reading (TTree * tree, std::string const & options)\fC [inline]\fP"

.SS "void Event::setT0 (\fBTimestamp\fP const & timestamp)\fC [inline]\fP"

.SS "\fBsize_t\fP Event::size () const\fC [inline]\fP"

.SS "auto& Event::time (int const & hit_i)\fC [inline]\fP"

.SS "auto& Event::time2 (int const & hit_i)\fC [inline]\fP"

.SS "\fBTime_ns\fP Event::time_ns (int const & i) const\fC [inline]\fP"

.SS "void Event::timeShift (\fBTime\fP const & shift)\fC [inline]\fP"

.SS "void Event::timeShift_ns (double const & shift)\fC [inline]\fP"

.SS "void Event::writting (TTree * tree, std::string const & options = \fC'lstTeEqQ'\fP)\fC [inline]\fP"

.SH "Member Data Documentation"
.PP 
.SS "\fBADC\fP Event::adcs[255] = {0}"

.SS "bool Event::isReading = false\fC [private]\fP"

.SS "bool Event::isWritting = false\fC [private]\fP"

.SS "\fBLabel\fP Event::labels[255] = {0}"

.SS "\fBsize_t\fP Event::m_maxSize = 255\fC [private]\fP"

.SS "int Event::mult = 0"

.SS "\fBNRJ\fP Event::nrj2s[255] = {0}"

.SS "\fBNRJ\fP Event::nrjs[255] = {0}"

.SS "\fBPileup\fP Event::pileups[255] = {0}"

.SS "\fBADC\fP Event::qdc2s[255] = {0}"

.SS "\fBIOptions\fP Event::read"

.SS "\fBTimestamp\fP Event::stamp = 0ull"

.SS "\fBTime_ns\fP Event::time2s[255] = {0}"

.SS "\fBTime\fP Event::times[255] = {0}"

.SS "\fBIOptions\fP Event::write"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
