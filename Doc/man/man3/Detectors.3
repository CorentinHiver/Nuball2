.TH "Detectors" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Detectors \- Loads the ID file and fills lookup tables\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Detectors\&.hpp>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBEmptyError\fP"
.br
.ti -1c
.RI "class \fBError\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "auto \fBbegin\fP ()"
.br
.ti -1c
.RI "auto \fBbegin\fP () const"
.br
.ti -1c
.RI "\fBDetectors\fP ()"
.br
.ti -1c
.RI "auto \fBend\fP ()"
.br
.ti -1c
.RI "auto \fBend\fP () const"
.br
.ti -1c
.RI "bool \fBexists\fP (\fBLabel\fP const &\fBlabel\fP)"
.br
.RI "Does this label correspond to a detector ? "
.ti -1c
.RI "auto const  & \fBfile\fP ()"
.br
.ti -1c
.RI "auto const  & \fBfile\fP () const"
.br
.ti -1c
.RI "auto const  & \fBget\fP () const"
.br
.ti -1c
.RI "auto const  & \fBgetExistsArray\fP () const"
.br
.ti -1c
.RI "auto const  & \fBgetLabel\fP (std::string const &\fBname\fP)"
.br
.ti -1c
.RI "auto const  & \fBgetLabelsMap\fP () const"
.br
.ti -1c
.RI "auto const  & \fBgetName\fP (\fBLabel\fP const &\fBlabel\fP)"
.br
.ti -1c
.RI "auto const  & \fBgetTypeName\fP (int const &type_i) const"
.br
.ti -1c
.RI "auto const  & \fBindex\fP (\fBLabel\fP const &\fBlabel\fP) const"
.br
.RI "Get the type index of the detector\&. Each type of detector has its own indexing system if you have 3 Germaniums, the Ge indexes ranges from 0 to 2) "
.ti -1c
.RI "auto const  & \fBlabel\fP (\fBdType\fP const &\fBtype\fP, int const &\fBindex\fP)"
.br
.RI "Get the global label of a detector given its type and type index\&. "
.ti -1c
.RI "auto const  & \fBlabel\fP (std::string const &\fBname\fP)"
.br
.ti -1c
.RI "auto const  & \fBlabels\fP () const"
.br
.ti -1c
.RI "auto const  & \fBlist\fP () const"
.br
.ti -1c
.RI "void \fBload\fP (std::string const &filename)"
.br
.RI "Reads the file and extracts the list of detectors, then fills the lookup tables\&. "
.ti -1c
.RI "void \fBmakeArrays\fP ()"
.br
.RI "Fills the lookup tables\&. "
.ti -1c
.RI "auto const  & \fBname\fP (\fBdType\fP const &\fBtype\fP, int const &\fBindex\fP)"
.br
.RI "Get the name of a detector given its type and type index\&. "
.ti -1c
.RI "auto const  & \fBnames\fP () const"
.br
.ti -1c
.RI "auto const  & \fBnbOfType\fP (\fBdType\fP const &\fBtype\fP)"
.br
.RI "Returns the number of detector of each type\&. "
.ti -1c
.RI "auto \fBnbTypes\fP ()"
.br
.RI "Returns the number of types in the ID file\&. "
.ti -1c
.RI "auto \fBnbTypes\fP () const"
.br
.ti -1c
.RI "auto const  & \fBnumber\fP ()"
.br
.RI "Return the number of detectors\&. "
.ti -1c
.RI "\fBoperator bool\fP () const &"
.br
.RI "Returns true only of the detectors ID file has been loaded successfully\&. "
.ti -1c
.RI "void \fBoperator=\fP (std::string const &filename)"
.br
.ti -1c
.RI "auto const  & \fBoperator[]\fP (\fBLabel\fP const &\fBlabel\fP) const"
.br
.RI "Extracts the name of the detector given its global label\&. "
.ti -1c
.RI "auto const  & \fBoperator[]\fP (std::string const &\fBname\fP)"
.br
.RI "Extracts the global label given the detector's name\&. "
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.RI "Prints out the list of labels\&. "
.ti -1c
.RI "void \fBreadFile\fP (std::string const &\fBfile\fP)"
.br
.RI "Reads the file and extracts the list of detectors\&. "
.ti -1c
.RI "void \fBresize\fP (\fBushort\fP const &new_size)"
.br
.ti -1c
.RI "\fBLabel\fP \fBsize\fP () const"
.br
.RI "Return the value of the maximum label, i\&.e\&. the size of the lookup tables\&. "
.ti -1c
.RI "auto const  & \fBtype\fP (\fBLabel\fP const &\fBlabel\fP)"
.br
.ti -1c
.RI "auto const  & \fBtypeIndex\fP (\fBdType\fP const &\fBtype\fP)"
.br
.ti -1c
.RI "auto const  & \fBtypeIndex\fP (\fBLabel\fP const &\fBlabel\fP)"
.br
.ti -1c
.RI "auto const  & \fBtypes\fP () const"
.br
.ti -1c
.RI "auto const  & \fBtypesArray\fP () const"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static auto const  & \fBADCBin\fP (\fBdType\fP const &\fBtype\fP='')"
.br
.RI "Get the default ADC histogram binning for each type of detectors\&. "
.ti -1c
.RI "static auto const  & \fBenergyBidimBin\fP (\fBdType\fP const &\fBtype\fP='')"
.br
.RI "Get the default energy (keV) bidimensionnal histogram binning for each type of detectors\&. "
.ti -1c
.RI "static auto const  & \fBenergyBin\fP (\fBdType\fP const &\fBtype\fP='')"
.br
.RI "Get the default energy (keV) histogram binning for each type of detectors\&. "
.ti -1c
.RI "static auto & \fBgetADCBin\fP ()"
.br
.RI "Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. "
.ti -1c
.RI "static auto & \fBgetBidimBin\fP ()"
.br
.RI "Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. "
.ti -1c
.RI "static auto & \fBgetEnergyBin\fP ()"
.br
.RI "Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBStrings\fP \fBtypes_handled\fP = {'ge', 'bgo', 'labr', 'paris', 'dssd', 'eden', 'RF', 'default'}"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBBools\fP \fBm_exists\fP"
.br
.ti -1c
.RI "std::string \fBm_filename\fP"
.br
.ti -1c
.RI "bool \fBm_Initialised\fP = false"
.br
.ti -1c
.RI "std::unordered_map< \fBdType\fP, \fBLabel_vec\fP > \fBm_labels\fP"
.br
.ti -1c
.RI "std::unordered_map< std::string, \fBLabel\fP > \fBm_labels_map\fP"
.br
.ti -1c
.RI "std::vector< \fBLabel\fP > \fBm_labels_vector\fP"
.br
.ti -1c
.RI "\fBStrings\fP \fBm_list\fP"
.br
.ti -1c
.RI "bool \fBm_loaded\fP = false"
.br
.ti -1c
.RI "std::unordered_map< \fBdType\fP, \fBStrings\fP > \fBm_names\fP"
.br
.ti -1c
.RI "\fBushort\fP \fBm_nb_detectors\fP = 0"
.br
.ti -1c
.RI "bool \fBm_ok\fP = false"
.br
.ti -1c
.RI "std::unordered_map< \fBdType\fP, int > \fBm_type_counter\fP"
.br
.ti -1c
.RI "\fBStrings\fP \fBm_types\fP = \fBStrings\fP(\fBSIZE_LOOKUP\fP)"
.br
.ti -1c
.RI "\fBStrings\fP \fBm_types_ID\fP"
.br
.ti -1c
.RI "std::unordered_map< \fBdType\fP, int > \fBm_types_index\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static std::unordered_map< \fBdType\fP, \fBTHBinning\fP > \fBADC_bins\fP"
.br
.ti -1c
.RI "static std::unordered_map< \fBdType\fP, \fBTHBinning\fP > \fBenergy_bidim_bins\fP"
.br
.ti -1c
.RI "static std::unordered_map< \fBdType\fP, \fBTHBinning\fP > \fBenergy_bins\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Loads the ID file and fills lookup tables\&. 

Many lookup tables are created : \&.\&.\&. Detectors::index(Label label) : Returns the detector's index in its type\&. For instance, if there are 10 germaniums, and their labels ranges contiguously from 10 to 19, Detectors::index(12) = 2;
.PP
Detectors::type(Label label) : Returns the detector's type knowing its label\&. Taking previous example, Detectors::type(25) = 'null' if there are no detector above label = 19, and Detectors::type(13) = 'ge'; 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Detectors::Detectors ()\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "static auto const& Detectors::ADCBin (\fBdType\fP const & type = \fC''\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default ADC histogram binning for each type of detectors\&. 
.SS "auto Detectors::begin ()\fC [inline]\fP"

.SS "auto Detectors::begin () const\fC [inline]\fP"

.SS "auto Detectors::end ()\fC [inline]\fP"

.SS "auto Detectors::end () const\fC [inline]\fP"

.SS "static auto const& Detectors::energyBidimBin (\fBdType\fP const & type = \fC''\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default energy (keV) bidimensionnal histogram binning for each type of detectors\&. 
.SS "static auto const& Detectors::energyBin (\fBdType\fP const & type = \fC''\fP)\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default energy (keV) histogram binning for each type of detectors\&. 
.SS "bool Detectors::exists (\fBLabel\fP const & label)\fC [inline]\fP"

.PP
Does this label correspond to a detector ? 
.SS "auto const& Detectors::file ()\fC [inline]\fP"

.SS "auto const& Detectors::file () const\fC [inline]\fP"

.SS "auto const& Detectors::get () const\fC [inline]\fP"

.SS "static auto& Detectors::getADCBin ()\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. 
.SS "static auto& Detectors::getBidimBin ()\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. 
.SS "static auto& Detectors::getEnergyBin ()\fC [inline]\fP, \fC [static]\fP"

.PP
Get the default energy (keV) bidimensionnal histogram binning for all types of detectors\&. 
.SS "auto const& Detectors::getExistsArray () const\fC [inline]\fP"

.SS "auto const& Detectors::getLabel (std::string const & name)\fC [inline]\fP"

.SS "auto const& Detectors::getLabelsMap () const\fC [inline]\fP"

.SS "auto const& Detectors::getName (\fBLabel\fP const & label)\fC [inline]\fP"

.SS "auto const& Detectors::getTypeName (int const & type_i) const\fC [inline]\fP"

.SS "auto const& Detectors::index (\fBLabel\fP const & label) const\fC [inline]\fP"

.PP
Get the type index of the detector\&. Each type of detector has its own indexing system if you have 3 Germaniums, the Ge indexes ranges from 0 to 2) 
.SS "auto const& Detectors::label (\fBdType\fP const & type, int const & index)\fC [inline]\fP"

.PP
Get the global label of a detector given its type and type index\&. 
.SS "auto const& Detectors::label (std::string const & name)\fC [inline]\fP"

.SS "auto const& Detectors::labels () const\fC [inline]\fP"

.SS "auto const& Detectors::list () const\fC [inline]\fP"

.SS "void Detectors::load (std::string const & filename)"

.PP
Reads the file and extracts the list of detectors, then fills the lookup tables\&. 
.SS "void Detectors::makeArrays ()"

.PP
Fills the lookup tables\&. 
.SS "auto const& Detectors::name (\fBdType\fP const & type, int const & index)\fC [inline]\fP"

.PP
Get the name of a detector given its type and type index\&. 
.SS "auto const& Detectors::names () const\fC [inline]\fP"

.SS "auto const& Detectors::nbOfType (\fBdType\fP const & type)\fC [inline]\fP"

.PP
Returns the number of detector of each type\&. 
.SS "auto Detectors::nbTypes ()\fC [inline]\fP"

.PP
Returns the number of types in the ID file\&. 
.SS "auto Detectors::nbTypes () const\fC [inline]\fP"

.SS "auto const& Detectors::number ()\fC [inline]\fP"

.PP
Return the number of detectors\&. 
.SS "Detectors::operator bool () const &\fC [inline]\fP"

.PP
Returns true only of the detectors ID file has been loaded successfully\&. 
.SS "void Detectors::operator= (std::string const & filename)\fC [inline]\fP"

.SS "auto const& Detectors::operator[] (\fBLabel\fP const & label) const\fC [inline]\fP"

.PP
Extracts the name of the detector given its global label\&. 
.SS "auto const& Detectors::operator[] (std::string const & name)\fC [inline]\fP"

.PP
Extracts the global label given the detector's name\&. 
.SS "void Detectors::Print ()\fC [inline]\fP"

.PP
Prints out the list of labels\&. 
.SS "void Detectors::readFile (std::string const & file)"

.PP
Reads the file and extracts the list of detectors\&. 
.SS "void Detectors::resize (\fBushort\fP const & new_size)"

.SS "\fBLabel\fP Detectors::size () const\fC [inline]\fP"

.PP
Return the value of the maximum label, i\&.e\&. the size of the lookup tables\&. 
.SS "auto const& Detectors::type (\fBLabel\fP const & label)\fC [inline]\fP"

.SS "auto const& Detectors::typeIndex (\fBdType\fP const & type)\fC [inline]\fP"

.SS "auto const& Detectors::typeIndex (\fBLabel\fP const & label)\fC [inline]\fP"

.SS "auto const& Detectors::types () const\fC [inline]\fP"

.SS "auto const& Detectors::typesArray () const\fC [inline]\fP"

.SH "Member Data Documentation"
.PP 
.SS "std::unordered_map< \fBdType\fP, \fBTHBinning\fP > Detectors::ADC_bins\fC [static]\fP, \fC [protected]\fP"
\fBInitial value:\fP
.PP
.nf
= 
{
  {"ge"     , {10000, 0\&., 200000\&. }},
  {"bgo"    , {1000 , 0\&., 200000\&. }},
  {"labr"   , {2000 , 0\&., 200000\&. }},
  {"paris"  , {2000 , 0\&., 200000\&. }},
  {"eden"   , {1000 , 0\&., 200000\&. }},
  {"dssd"   , {1000 , 0\&., 200000\&. }},
  {"default", {10000, 0\&., 1000000\&.}}
}
.fi
.SS "std::unordered_map< \fBdType\fP, \fBTHBinning\fP > Detectors::energy_bidim_bins\fC [static]\fP, \fC [protected]\fP"
\fBInitial value:\fP
.PP
.nf
= 
{
  {"ge"     , {5000, 0\&., 10000\&.}},
  {"bgo"    , {250 , 0\&., 10000\&.}},
  {"labr"   , {1000, 0\&., 10000\&.}},
  {"paris"  , {1000, 0\&., 10000\&.}},
  {"eden"   , {1000,-2\&., 2\&.    }},
  {"dssd"   , {200 , 0\&., 20000\&.}},
  {"default", {200 , 0\&., 20000\&.}}
}
.fi
.SS "std::unordered_map< \fBdType\fP, \fBTHBinning\fP > Detectors::energy_bins\fC [static]\fP, \fC [protected]\fP"
\fBInitial value:\fP
.PP
.nf
= 
{
  {"ge"     , {10000, 0\&., 10000\&.}},
  {"bgo"    , {1000 , 0\&., 10000\&.}},
  {"labr"   , {2000 , 0\&., 10000\&.}},
  {"paris"  , {2000 , 0\&., 10000\&.}},
  {"eden"   , {1000 ,-2\&., 2\&.    }},
  {"dssd"   , {1000 , 0\&., 20000\&.}},
  {"default", {1000 , 0\&., 50000\&.}}
}
.fi
.SS "\fBBools\fP Detectors::m_exists\fC [protected]\fP"

.SS "std::string Detectors::m_filename\fC [protected]\fP"

.SS "bool Detectors::m_Initialised = false\fC [protected]\fP"

.SS "std::unordered_map<\fBdType\fP, \fBLabel_vec\fP> Detectors::m_labels\fC [protected]\fP"

.SS "std::unordered_map<std::string, \fBLabel\fP> Detectors::m_labels_map\fC [protected]\fP"

.SS "std::vector<\fBLabel\fP> Detectors::m_labels_vector\fC [protected]\fP"

.SS "\fBStrings\fP Detectors::m_list\fC [protected]\fP"

.SS "bool Detectors::m_loaded = false\fC [protected]\fP"

.SS "std::unordered_map<\fBdType\fP, \fBStrings\fP> Detectors::m_names\fC [protected]\fP"

.SS "\fBushort\fP Detectors::m_nb_detectors = 0\fC [protected]\fP"

.SS "bool Detectors::m_ok = false\fC [protected]\fP"

.SS "std::unordered_map<\fBdType\fP, int> Detectors::m_type_counter\fC [protected]\fP"

.SS "\fBStrings\fP Detectors::m_types = \fBStrings\fP(\fBSIZE_LOOKUP\fP)\fC [protected]\fP"

.SS "\fBStrings\fP Detectors::m_types_ID\fC [protected]\fP"

.SS "std::unordered_map<\fBdType\fP, int> Detectors::m_types_index\fC [protected]\fP"

.SS "\fBStrings\fP Detectors::types_handled = {'ge', 'bgo', 'labr', 'paris', 'dssd', 'eden', 'RF', 'default'}"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
