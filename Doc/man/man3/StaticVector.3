.TH "StaticVector< T >" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StaticVector< T > \- An efficient container for dynamic arrays with a known and fixed maximum size\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_functions\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "T const  & \fBat\fP (\fBstd::size_t\fP const &i) const"
.br
.RI "Return the ith element and check i do not exceed the size of the vector\&. "
.ti -1c
.RI "virtual T * \fBbegin\fP ()"
.br
.RI "Return iterator to the beginning of the vector\&. "
.ti -1c
.RI "virtual T * \fBbegin\fP () const"
.br
.RI "Return iterator to the beginning of the vector\&. "
.ti -1c
.RI "void \fBcheckCapacity\fP ()"
.br
.ti -1c
.RI "void \fBcheckCapacity\fP () const"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "T * \fBdata\fP ()"
.br
.RI "Return a pointer to the underlying data\&. "
.ti -1c
.RI "void \fBdeallocate\fP ()"
.br
.RI "Deletes the underlying data\&. "
.ti -1c
.RI "virtual T * \fBend\fP ()"
.br
.RI "Return iterator to the end of the vector\&. "
.ti -1c
.RI "virtual T * \fBend\fP () const"
.br
.RI "Return iterator to the end of the vector\&. "
.ti -1c
.RI "void \fBfill\fP (T const &e)"
.br
.RI "Fills the vector with element e within user size\&. "
.ti -1c
.RI "void \fBfill_static\fP (T const &e)"
.br
.RI "Fills the vector with element e within static size\&. "
.ti -1c
.RI "virtual bool \fBhas\fP (T &t) const"
.br
.RI "Does the vector contain element e ? "
.ti -1c
.RI "virtual bool \fBhas\fP (T const &t) const"
.br
.RI "Does the vector contain element e ? "
.ti -1c
.RI "void \fBmove_back\fP (T &&e)"
.br
.RI "Move the element to the back of the vector\&. Use for performances\&. Unsafe\&. define SAFE for less performance but size checking\&. "
.ti -1c
.RI "\fBStaticVector\fP & \fBoperator=\fP (\fBStaticVector\fP< T > const &vector)"
.br
.RI "Copy the values of another vector\&. "
.ti -1c
.RI "T & \fBoperator[]\fP (\fBstd::size_t\fP const &i) const"
.br
.RI "Return the ith element\&. "
.ti -1c
.RI "void \fBpush_back\fP (T const &e)"
.br
.RI "Add element to the back of the vector\&. Use for performances\&. Unsafe\&. define SAFE for less performance but size checking\&. "
.ti -1c
.RI "bool \fBpush_back_unique\fP (T const &t)"
.br
.RI "Add element to the back of the vector only if the vector do not contain it\&. "
.ti -1c
.RI "void \fBreserve\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (\fBstd::size_t\fP const &new_size=0)"
.br
.RI "Only reset the user size to new_size (default 0)\&. Do not touch the data\&. Use for performances\&. "
.ti -1c
.RI "auto const  & \fBsize\fP () const"
.br
.RI "Return the position of the write cursor\&. "
.ti -1c
.RI "void \fBstatic_resize\fP (\fBstd::size_t\fP const &new_size, T const &t)"
.br
.ti -1c
.RI "void \fBstatic_resize\fP (\fBstd::size_t\fP const &new_size=0)"
.br
.RI "Delete memory, reset the user size to 0 and allocate new_size memory\&. "
.ti -1c
.RI "\fBStaticVector\fP ()=default"
.br
.ti -1c
.RI "\fBStaticVector\fP (\fBStaticVector\fP< T > &&other)"
.br
.RI "Move contructor\&. "
.ti -1c
.RI "\fBStaticVector\fP (\fBStaticVector\fP< T > const &vector)"
.br
.RI "Create a new Static_vector by copy (duplicate) "
.ti -1c
.RI "\fBStaticVector\fP (\fBstd::size_t\fP const &static_size)"
.br
.RI "Create a new Static_vector with size static_size\&. "
.ti -1c
.RI "\fBStaticVector\fP (\fBstd::size_t\fP const &static_size, T const &e)"
.br
.RI "Create a new Static_vector with size static_size and fill it with element e\&. "
.ti -1c
.RI "\fB~StaticVector\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "T * \fBm_data\fP"
.br
.ti -1c
.RI "bool \fBm_deleted\fP = false"
.br
.ti -1c
.RI "\fBsize_t\fP \fBm_dynamic_size\fP = 0"
.br
.ti -1c
.RI "\fBsize_t\fP \fBm_static_size\fP = 0"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T>
.br
class StaticVector< T >"
An efficient container for dynamic arrays with a known and fixed maximum size\&. 


.PP
\fBAttention\fP
.RS 4
Prototype, has some memory management issues in some cases \&.\&.\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
With optimisation option, std::vector is almost as efficient as this class \&.\&.\&. 
.RE
.PP
.PP
This class is meant to handle a vector of data that needs to be resized a lot\&. To do so, declare it this way : 
.PP
.nf
 static_vector<T> my_vec = static_vector<T>(maximum_size);

.fi
.PP
 If not in an object prototype, simply : 
.PP
.nf
 auto my_vec = static_vector<T>(maximum_size);

.fi
.PP
 You can fill the whole vector with some value : 
.PP
.nf
 auto my_vec = static_vector<T>(maximum_size, fill_value);
 // or :
 my_vec.fill(fill_value);

.fi
.PP
 Now, you can use this vector just like a regular std::vector : 
.PP
.nf
 my_vec.push_back(t);
 my_vec.push_back(t2);
 my_vec.push_back(t3);
 // Do some stuff
 my_vec.resize(0);

.fi
.PP
 
.PP
\fBAttention\fP
.RS 4
keep in mind you cannot exceed the capacity of the vector\&.
.RE
.PP
If you want not to crash you application if the capacity is reached, use push_back_safe instead\&.
.PP
An interesting feature is push_back_unique(t)\&. This allows one to push_back t only if it has not been found in the vector\&. It may require t to have a comparison operator (not tested yet)\&.
.PP
Now, if for some reason you want to modify the capacity of the vector, you can use static_resize(new_size)\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T > \fBStaticVector\fP< T >::\fBStaticVector\fP ()\fC [default]\fP"

.SS "template<class T > \fBStaticVector\fP< T >::\fBStaticVector\fP (\fBstd::size_t\fP const & static_size)\fC [inline]\fP"

.PP
Create a new Static_vector with size static_size\&. 
.SS "template<class T > \fBStaticVector\fP< T >::\fBStaticVector\fP (\fBstd::size_t\fP const & static_size, T const & e)\fC [inline]\fP"

.PP
Create a new Static_vector with size static_size and fill it with element e\&. 
.SS "template<class T > \fBStaticVector\fP< T >::\fBStaticVector\fP (\fBStaticVector\fP< T > const & vector)\fC [inline]\fP"

.PP
Create a new Static_vector by copy (duplicate) 
.SS "template<class T > \fBStaticVector\fP< T >::\fBStaticVector\fP (\fBStaticVector\fP< T > && other)\fC [inline]\fP"

.PP
Move contructor\&. 
.SS "template<class T > \fBStaticVector\fP< T >::~\fBStaticVector\fP ()\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<class T > T const& \fBStaticVector\fP< T >::at (\fBstd::size_t\fP const & i) const\fC [inline]\fP"

.PP
Return the ith element and check i do not exceed the size of the vector\&. 
.SS "template<class T > virtual T* \fBStaticVector\fP< T >::begin ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Return iterator to the beginning of the vector\&. 
.SS "template<class T > virtual T* \fBStaticVector\fP< T >::begin () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Return iterator to the beginning of the vector\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::checkCapacity ()\fC [inline]\fP"

.SS "template<class T > void \fBStaticVector\fP< T >::checkCapacity () const\fC [inline]\fP"

.SS "template<class T > void \fBStaticVector\fP< T >::clear ()\fC [inline]\fP"

.SS "template<class T > T* \fBStaticVector\fP< T >::data ()\fC [inline]\fP"

.PP
Return a pointer to the underlying data\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::deallocate ()\fC [inline]\fP"

.PP
Deletes the underlying data\&. 
.SS "template<class T > virtual T* \fBStaticVector\fP< T >::end ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Return iterator to the end of the vector\&. 
.SS "template<class T > virtual T* \fBStaticVector\fP< T >::end () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Return iterator to the end of the vector\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::fill (T const & e)\fC [inline]\fP"

.PP
Fills the vector with element e within user size\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::fill_static (T const & e)\fC [inline]\fP"

.PP
Fills the vector with element e within static size\&. 
.SS "template<class T > virtual bool \fBStaticVector\fP< T >::has (T & t) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Does the vector contain element e ? 
.PP
\fBParameters\fP
.RS 4
\fIt\fP direct access to the variable 
.RE
.PP

.SS "template<class T > virtual bool \fBStaticVector\fP< T >::has (T const & t) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Does the vector contain element e ? 
.PP
\fBParameters\fP
.RS 4
\fIt\fP variable in read-only mode 
.RE
.PP

.SS "template<class T > void \fBStaticVector\fP< T >::move_back (T && e)\fC [inline]\fP"

.PP
Move the element to the back of the vector\&. Use for performances\&. Unsafe\&. define SAFE for less performance but size checking\&. 
.SS "template<class T > \fBStaticVector\fP& \fBStaticVector\fP< T >::operator= (\fBStaticVector\fP< T > const & vector)\fC [inline]\fP"

.PP
Copy the values of another vector\&. 
.SS "template<class T > T& \fBStaticVector\fP< T >::operator[] (\fBstd::size_t\fP const & i) const\fC [inline]\fP"

.PP
Return the ith element\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::push_back (T const & e)\fC [inline]\fP"

.PP
Add element to the back of the vector\&. Use for performances\&. Unsafe\&. define SAFE for less performance but size checking\&. 
.SS "template<class T > bool \fBStaticVector\fP< T >::push_back_unique (T const & t)\fC [inline]\fP"

.PP
Add element to the back of the vector only if the vector do not contain it\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::reserve ()\fC [inline]\fP"

.SS "template<class T > void \fBStaticVector\fP< T >::resize (\fBstd::size_t\fP const & new_size = \fC0\fP)\fC [inline]\fP"

.PP
Only reset the user size to new_size (default 0)\&. Do not touch the data\&. Use for performances\&. 
.SS "template<class T > auto const& \fBStaticVector\fP< T >::size () const\fC [inline]\fP"

.PP
Return the position of the write cursor\&. 
.SS "template<class T > void \fBStaticVector\fP< T >::static_resize (\fBstd::size_t\fP const & new_size, T const & t)\fC [inline]\fP"

.SS "template<class T > void \fBStaticVector\fP< T >::static_resize (\fBstd::size_t\fP const & new_size = \fC0\fP)\fC [inline]\fP"

.PP
Delete memory, reset the user size to 0 and allocate new_size memory\&. 
.SH "Member Data Documentation"
.PP 
.SS "template<class T > T* \fBStaticVector\fP< T >::m_data\fC [private]\fP"

.SS "template<class T > bool \fBStaticVector\fP< T >::m_deleted = false\fC [private]\fP"

.SS "template<class T > \fBsize_t\fP \fBStaticVector\fP< T >::m_dynamic_size = 0\fC [private]\fP"

.SS "template<class T > \fBsize_t\fP \fBStaticVector\fP< T >::m_static_size = 0\fC [private]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
