.TH "Hit" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Hit \- \fBHit\fP class ///\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Hit\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBHit\fP ()"
.br
.ti -1c
.RI "\fBHit\fP (\fBHit\fP const &hit)"
.br
.ti -1c
.RI "\fBHit\fP & \fBoperator=\fP (\fBHit\fP const &hit)"
.br
.ti -1c
.RI "void \fBreading\fP (TTree *tree)"
.br
.ti -1c
.RI "void \fBreading\fP (TTree *tree, std::string const &options)"
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "void \fBwritting\fP (TTree *tree, std::string const &options='lseqp')"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBADC\fP \fBadc\fP = 0"
.br
.ti -1c
.RI "\fBLabel\fP \fBlabel\fP = 0"
.br
.ti -1c
.RI "\fBNRJ\fP \fBnrj\fP = 0\&.f"
.br
.ti -1c
.RI "\fBNRJ\fP \fBnrj2\fP = 0\&.f"
.br
.ti -1c
.RI "\fBNRJ\fP \fBnrj3\fP = 0\&.f"
.br
.ti -1c
.RI "bool \fBpileup\fP = false"
.br
.ti -1c
.RI "\fBADC\fP \fBqdc2\fP = 0"
.br
.ti -1c
.RI "\fBADC\fP \fBqdc3\fP = 0"
.br
.ti -1c
.RI "\fBTimestamp\fP \fBstamp\fP = 0ull"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static \fBIOptions\fP \fBread\fP"
.br
.ti -1c
.RI "static \fBIOptions\fP \fBwrite\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBHit\fP class ///\&. 

This class is used to store conviniently the data from reading the faster data\&. You can either treat data directly or write it in root trees
.PP
This class is used as an interface between the faster data and root\&.
.PP
Connect it to a \fBFasterReader\fP to read data : 
.PP
.nf
 Hit hit;
 FasterReader.setHit(&hit);
 while(reader.Read())
 {
   doSomething with the hit...
 }

.fi
.PP
 Connect it to a Root Tree :
.PP
.IP "1." 4
To convert data to a raw root tree :
.PP
\fBHit\fP hit; TTree * tree = new TTree('Nuball2','Nuball2'); FasterReader\&.setHit(&hit); hit\&.writting(tree); while(reader\&.Read()) { tree -> Fill(); }
.IP "2." 4
To read this raw root tree :
.PP
hit\&.reading(tree); for (int hit = 0; hit<tree->GetEntries(); hit++) { do somethign with the hit \&.\&.\&. } 
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Hit::Hit ()\fC [inline]\fP"

.SS "Hit::Hit (\fBHit\fP const & hit)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBHit\fP& Hit::operator= (\fBHit\fP const & hit)\fC [inline]\fP"

.SS "void Hit::reading (TTree * tree)"

.SS "void Hit::reading (TTree * tree, std::string const & options)"

.SS "void Hit::reset ()\fC [inline]\fP"

.SS "void Hit::writting (TTree * tree, std::string const & options = \fC'lseqp'\fP)"

.SH "Member Data Documentation"
.PP 
.SS "\fBADC\fP Hit::adc = 0"

.SS "\fBLabel\fP Hit::label = 0"

.SS "\fBNRJ\fP Hit::nrj = 0\&.f"

.SS "\fBNRJ\fP Hit::nrj2 = 0\&.f"

.SS "\fBNRJ\fP Hit::nrj3 = 0\&.f"

.SS "bool Hit::pileup = false"

.SS "\fBADC\fP Hit::qdc2 = 0"

.SS "\fBADC\fP Hit::qdc3 = 0"

.SS "\fBIOptions\fP Hit::read\fC [static]\fP"

.SS "\fBTimestamp\fP Hit::stamp = 0ull"

.SS "\fBIOptions\fP Hit::write\fC [static]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
