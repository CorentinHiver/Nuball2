.TH "MTObject" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MTObject \- Class handeling an easy multi threading\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MTObject\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMTObject\fP ()"
.br
.ti -1c
.RI "\fBMTObject\fP (\fBsize_t\fP &_nb_threads)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBadjustThreadsNumber\fP (\fBsize_t\fP const &limiting_number, std::string const &print_if_limit_reached='')"
.br
.ti -1c
.RI "static auto const  & \fBgetThreadIndex\fP ()"
.br
.ti -1c
.RI "static auto const  & \fBgetThreadsNb\fP ()"
.br
.ti -1c
.RI "static auto const  & \fBgetThreadsNumber\fP ()"
.br
.ti -1c
.RI "static auto const  & \fBindex\fP ()"
.br
.ti -1c
.RI "static void \fBInitialise\fP ()"
.br
.ti -1c
.RI "static void \fBInitialise\fP (\fBsize_t\fP const &_nb_threads, bool force=false)"
.br
.ti -1c
.RI "static bool \fBisMasterThread\fP ()"
.br
.ti -1c
.RI "template<class Func , class\&.\&.\&. ARGS> static void \fBparallelise_function\fP (Func &&func, ARGS &&\&.\&.\&. args)"
.br
.ti -1c
.RI "static void \fBsetThreadsNb\fP (int const &n, bool force=false) noexcept"
.br
.RI "Sets the number of threads\&. "
.ti -1c
.RI "static void \fBsetThreadsNb\fP (\fBsize_t\fP const &n, bool force=false) noexcept"
.br
.RI "Sets the number of threads\&. "
.ti -1c
.RI "static void \fBsignalHandler\fP (int signal)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static bool \fBactivated\fP = false"
.br
.ti -1c
.RI "static bool \fBkill\fP = false"
.br
.ti -1c
.RI "static std::mutex \fBmutex\fP"
.br
.ti -1c
.RI "static \fBsize_t\fP \fBnb_threads\fP = 1"
.br
.ti -1c
.RI "static bool \fBON\fP = false"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static bool \fBm_Initialised\fP = false"
.br
.ti -1c
.RI "static thread_local \fBsize_t\fP \fBm_thread_index\fP = 0"
.br
.ti -1c
.RI "static std::vector< std::thread > \fBm_threads\fP"
.br
.ti -1c
.RI "static std::thread::id \fBmaster_thread_id\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class handeling an easy multi threading\&. 


.PP
\fBAttention\fP
.RS 4
Include this class before any other in order to activate multithreading additions
.RE
.PP
POSIX-based multithreading\&. If you want to use the power of multithreading, this class can be convenient\&. Please include this class before any other in order to activate multithreading additions in the rest of the library\&.
.PP
First thing to do is to setup the number of threads then to Initialise them : 
.PP
.nf
   MTObject::setThreadsNb(nb_threads);
   MTObject::Initialise();

.fi
.PP
 Or more consisley : 
.PP
.nf
   MTObject::Initialise(nb_threads);

.fi
.PP
 Then you can multithread any function or static method : 
.PP
.nf
   MTObject::parallelise_function(function, param1, param2, ....);

.fi
.PP
 If you want to multithread a non-static method (regular methods in an object), you need to pass through a static function first\&.
.PP
Example 1 : simplest example : parallelise a lambda\&. 
.PP
.nf
   main()
   {
     MTObject::Initialise(2); // Using two concurrent threads
     int a = 0;
     int b = 0;
     // Here, the [&] allows the lambda to have access at everything that has been declared above. 
     // Therefore, in this case the lambda don't need any argument and the '()' is empty
     MTObject::parallelise_function([&](){
       if (random_uniform(0, 1)>0.5) ++a; // the random_uniform() is thread safe if '#include<MTObject>' is included first
       else                          ++b;
     });
     print(a, b);

.fi
.PP
 Example 2 : parallelise a lambda and fill a histogram using \fBMTTHist\fP 
.PP
.nf
   main()
   {
     MTObject::Initialise(2); // Using two concurrent threads
     MTTHist<TH1F> test("test", "test", 1000,0,1000); // MTTHist holds a vector of TH1F to be filled using its own Fill method

     MTObject::parallelise_function([&]()
     { // Here starts the parallelised portion of code
       print("thread id :", MTObject::getThreadIndex()); // You can access the current thread index (0 or 1 in this case)
       // This method automatically fills the copy of the histogram that corresponds to its thread index :
       for(int i = 0; i<10000000; i++) test.Fill(random_gaussian(500, 100)); 
     });
     // Now, you may want to perform some operations on the MTTHist. 
     // But before, you need to merge the copies into one single spectra using MTTHist::Merge
     test.Merge();
     // Now, you can access the fused histogram using '->' operator.
     // It calls the TH1F itself, so you have access at all the 
     print(test->GetMean());
     auto outfile(TFile::Open("test.root", "RECREATE"));
     outfile->cd();
     // Note : you can use the MTTHist::Write method without already merged it
     test.Write();
     outfile->Write();
     outfile->Close();
     return 0;
   }

.fi
.PP
 Example 3 : paralellise a non-static method of a class : 
.PP
.nf
   class MyClass
   {
   public:
     MyClass() {}
     void function_to_multithread(argument_1, argument_2, ...){....}

     static void helper_function(MyClass & myclass, argument_1, argument_2, ...) {return myclass.function_to_multithread(argument_1, argument_2, ...);}
   };

   int main()
   {
    ...
     MTObject::parallelise_function(myclass.helper_function, argument_1, argument_2, ....);
    ...
   }

.fi
.PP
 
.PP
\fBTodo\fP
.RS 4
Trying to make this work : template<class\&.\&.\&. ARGS> static ret_type helper_function(MyClass & myclass, ARGS\&.\&.\&. args) {return myclass\&.function_to_multithread(std::forward<ARGS>(args)\&.\&.\&.);} 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "MTObject::MTObject ()\fC [inline]\fP"

.SS "MTObject::MTObject (\fBsize_t\fP & _nb_threads)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "static void MTObject::adjustThreadsNumber (\fBsize_t\fP const & limiting_number, std::string const & print_if_limit_reached = \fC''\fP)\fC [inline]\fP, \fC [static]\fP"

.SS "static auto const& MTObject::getThreadIndex ()\fC [inline]\fP, \fC [static]\fP"

.SS "static auto const& MTObject::getThreadsNb ()\fC [inline]\fP, \fC [static]\fP"

.SS "static auto const& MTObject::getThreadsNumber ()\fC [inline]\fP, \fC [static]\fP"

.SS "static auto const& MTObject::index ()\fC [inline]\fP, \fC [static]\fP"

.SS "static void MTObject::Initialise ()\fC [inline]\fP, \fC [static]\fP"

.SS "static void MTObject::Initialise (\fBsize_t\fP const & _nb_threads, bool force = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP"

.SS "static bool MTObject::isMasterThread ()\fC [inline]\fP, \fC [static]\fP"

.SS "template<class Func , class\&.\&.\&. ARGS> static void MTObject::parallelise_function (Func && func, ARGS &&\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP"

.PP
\fBTodo\fP
.RS 4
check if I can replace Func by std::function 
.RE
.PP

.SS "static void MTObject::setThreadsNb (int const & n, bool force = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Sets the number of threads\&. Check the number of threads\&. Usually, over 75% of cores is the optimal\&. Set force parameter to true if you want to use all the cores 
.SS "static void MTObject::setThreadsNb (\fBsize_t\fP const & n, bool force = \fCfalse\fP)\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Sets the number of threads\&. Check the number of threads\&. Usually, over 75% of cores is the optimal\&. Set force parameter to true if you want to use all the cores 
.SS "static void MTObject::signalHandler (int signal)\fC [inline]\fP, \fC [static]\fP"

.SH "Member Data Documentation"
.PP 
.SS "bool MTObject::activated = false\fC [static]\fP"

.SS "bool MTObject::kill = false\fC [static]\fP"

.SS "bool MTObject::m_Initialised = false\fC [static]\fP, \fC [private]\fP"

.SS "thread_local \fBsize_t\fP MTObject::m_thread_index = 0\fC [static]\fP, \fC [private]\fP"

.SS "std::vector< std::thread > MTObject::m_threads\fC [static]\fP, \fC [private]\fP"

.SS "std::thread::id MTObject::master_thread_id\fC [static]\fP, \fC [private]\fP"

.SS "std::mutex MTObject::mutex\fC [static]\fP"

.SS "\fBsize_t\fP MTObject::nb_threads = 1\fC [static]\fP"

.SS "bool MTObject::ON = false\fC [static]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
