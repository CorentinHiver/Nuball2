.TH "lib/libRoot.hpp" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/libRoot.hpp
.SH SYNOPSIS
.br
.PP
\fC#include 'libCo\&.hpp'\fP
.br
\fC#include <TAxis\&.h>\fP
.br
\fC#include <TCanvas\&.h>\fP
.br
\fC#include <TChain\&.h>\fP
.br
\fC#include <TError\&.h>\fP
.br
\fC#include <TF1\&.h>\fP
.br
\fC#include <TF2\&.h>\fP
.br
\fC#include <TFile\&.h>\fP
.br
\fC#include <TFitResultPtr\&.h>\fP
.br
\fC#include <TFitResult\&.h>\fP
.br
\fC#include <TGraph\&.h>\fP
.br
\fC#include <TGraphErrors\&.h>\fP
.br
\fC#include <TH1F\&.h>\fP
.br
\fC#include <TH1D\&.h>\fP
.br
\fC#include <TH1S\&.h>\fP
.br
\fC#include <TH2\&.h>\fP
.br
\fC#include <TH2F\&.h>\fP
.br
\fC#include <TH3I\&.h>\fP
.br
\fC#include <TKey\&.h>\fP
.br
\fC#include <TLeaf\&.h>\fP
.br
\fC#include <TLegend\&.h>\fP
.br
\fC#include <TMarker\&.h>\fP
.br
\fC#include <TMath\&.h>\fP
.br
\fC#include <TRandom\&.h>\fP
.br
\fC#include <TROOT\&.h>\fP
.br
\fC#include <TSpectrum\&.h>\fP
.br
\fC#include <TStopwatch\&.h>\fP
.br
\fC#include <TString\&.h>\fP
.br
\fC#include <TStyle\&.h>\fP
.br
\fC#include <TSystem\&.h>\fP
.br
\fC#include <TThread\&.h>\fP
.br
\fC#include <TTree\&.h>\fP
.br
\fC#include <TTreeIndex\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBBiggestPeakFitter\fP"
.br
.RI "Allows one to find the most significant peak in the range [low_edge, high_edge]\&. "
.ti -1c
.RI "class \fBPeakFitter\fP"
.br
.RI "Allows one to fit a peak of a histogram in the range [low_edge, high_edge]\&. "
.ti -1c
.RI "struct \fBTHBinning\fP"
.br
.RI "Binning of a root histogram (TH1) : number of bins, min value, max value\&. "
.ti -1c
.RI "class \fBTheTChain\fP"
.br
.RI "Not functionnal yet\&. "
.ti -1c
.RI "class \fBTypeRootMap\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBCoAnalyse\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBCoAnalyse::ProjectionsBins\fP = std::vector< std::pair< double, double > >"
.br
.RI "Vector of pairs of min and max bins\&. "
.ti -1c
.RI "using \fBTH1F_map\fP = std::map< std::string, TH1F * >"
.br
.ti -1c
.RI "using \fBunique_TFile\fP = std::unique_ptr< TFile >"
.br
.ti -1c
.RI "using \fBunique_TH1F\fP = std::unique_ptr< TH1F >"
.br
.ti -1c
.RI "using \fBunique_TH2F\fP = std::unique_ptr< TH2F >"
.br
.ti -1c
.RI "using \fBunique_tree\fP = std::unique_ptr< TTree >"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBAddTH1\fP (TH1 *histo_total, TH1 *histo)"
.br
.RI "Patch to the TH1::Add method when the histograms limits are inconsistent\&. "
.ti -1c
.RI "bool \fBAddTH1\fP (TH2 *histo2, TH1 *histo1, int index, bool x=true)"
.br
.ti -1c
.RI "bool \fBAddTH1ByValue\fP (TH2 *histo2, TH1 *histo1, int index, bool x=true)"
.br
.RI "Like AddTH1 but adjusts the binning first\&. "
.ti -1c
.RI "void \fBalignator\fP (TTree *tree, int *NewIndex)"
.br
.ti -1c
.RI "template<class T > std::map< std::string, T > \fBcreate_map_of\fP (TFile *file)"
.br
.ti -1c
.RI "template<class T > auto \fBcreateBranch\fP (TTree *tree, T *value, std::string const &name, int buffsize=64000)"
.br
.RI "Create a branch for a given value and name\&. "
.ti -1c
.RI "template<class T > auto \fBcreateBranchArray\fP (TTree *tree, T *array, std::string const &name, std::string const &name_size, int buffsize=64000)"
.br
.RI "Create a branch for a given array and name\&. "
.ti -1c
.RI "void \fBdraw_all_TH1\fP (std::string const &filename, int minX=0, int maxX=0, int rebin=1, std::string pattern='')"
.br
.RI "Draws all the TH1F of a given file one by one\&. "
.ti -1c
.RI "std::vector< double > \fBCoAnalyse::extractBackgroundArray\fP (std::vector< double > &source, int const &nsmooth=10)"
.br
.ti -1c
.RI "std::vector< double > \fBCoAnalyse::extractBackgroundArray\fP (TH1F *histo, int const &nsmooth=10)"
.br
.ti -1c
.RI "int \fBfindNextBinAbove\fP (TH1 *histo, int &bin, double threshold)"
.br
.ti -1c
.RI "int \fBfindNextBinBelow\fP (TH1 *histo, int &bin, double threshold)"
.br
.ti -1c
.RI "void \fBfuse_all_histo\fP (std::string const &folder, std::string const &outRoot='fused_histo\&.root', bool const &bidim=true)"
.br
.RI "allows one to fuse all the histograms with the same name from different files "
.ti -1c
.RI "template<class T > std::vector< std::string > \fBget_names_of\fP (TFile *file)"
.br
.ti -1c
.RI "\fBTH1F_map\fP \fBget_TH1F_map\fP (TFile *file)"
.br
.ti -1c
.RI "\fBTH1F_map\fP \fBget_TH1F_map\fP (TFile *file, std::vector< std::string > &names)"
.br
.ti -1c
.RI "std::vector< std::string > \fBget_TH1F_names\fP (std::string const &filename)"
.br
.ti -1c
.RI "std::vector< std::string > \fBget_TH1F_names\fP (TFile *file)"
.br
.ti -1c
.RI "int \fBgetBin0\fP (TH1F *spectra)"
.br
.RI "Get which bin holds the X = 0\&. "
.ti -1c
.RI "void \fBgetData\fP (TH1 *histo, std::vector< double > &data)"
.br
.ti -1c
.RI "void \fBgetData\fP (TH1 *histo, std::vector< float > &data)"
.br
.ti -1c
.RI "bool \fBgetMeanPeak\fP (TH1F *spectra, double &mean)"
.br
.RI "Get the mean of the peak of a histogram with one nice single peak\&. "
.ti -1c
.RI "void \fBGetPoint\fP (TVirtualPad *vpad, double &x, double &y)"
.br
.RI "This method allows one to get the x and y values of where the user clicks on the graph\&. "
.ti -1c
.RI "void \fBlibRoot\fP ()"
.br
.ti -1c
.RI "template<typename T , typename  = typename std::enable_if<std::is_arithmetic<T>::value>::type> Long64_t \fBLong64_cast\fP (T const &t)"
.br
.RI "Casts a number into unsigned short\&. "
.ti -1c
.RI "float \fBmaxXaxis\fP (TH1 *histo)"
.br
.ti -1c
.RI "float \fBmaxYaxis\fP (TH1 *histo)"
.br
.ti -1c
.RI "double \fBMeanBetweenEdges\fP (TH1F *hist, double edge1, double edge2)"
.br
.ti -1c
.RI "float \fBminXaxis\fP (TH1 *histo)"
.br
.ti -1c
.RI "float \fBminYaxis\fP (TH1 *histo)"
.br
.ti -1c
.RI "void \fBCoAnalyse::normalizeBidim\fP (TH2 *matrix, double const &factor=1\&.0)"
.br
.RI "Normalise the whole bidim\&. "
.ti -1c
.RI "void \fBCoAnalyse::normalizeY\fP (TH2 *matrix, double const &factor=1)"
.br
.RI "For each X bin, normalise the Y histogram\&. "
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &cout, \fBTHBinning\fP binning)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &out, TTree *tree)"
.br
.ti -1c
.RI "void \fBCoAnalyse::projectX\fP (TH2 *matrix, TH1 *proj)"
.br
.RI "Project the whole matrix on the X axis\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectX\fP (TH2 *matrix, TH1 *proj, double const &binYmin, double const &binYmax)"
.br
.RI "Project on Y axis between values binYmin and binYmax included [binYmin;binYmax]\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectX\fP (TH2 *matrix, TH1 *proj, int const &binY)"
.br
.RI "Project on X axis at a given Y bin\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectX\fP (TH2 *matrix, TH1 *proj, int const &binYmin, int const &binYmax)"
.br
.RI "Project on X axis between bin binYmin included and binYmax excluded [binYmin;binYmax[\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectY\fP (TH2 *matrix, TH1 *proj, double const &valueXmin, double const &valueXmax)"
.br
.RI "Project matrix on Y axis between values valueXmin and valueXmax included [valueXmin;valueXmax]\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectY\fP (TH2 *matrix, TH1 *proj, int const &binX)"
.br
.RI "Project matrix on Y axis at a given X bin\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::projectY\fP (TH2 *matrix, TH1 *proj, int const &binXmin, int const &binXmax)"
.br
.RI "Project matrix on Y axis between bin binXmin included and binXmax excluded [binXmin;binXmax[\&. This fills proj\&. "
.ti -1c
.RI "void \fBCoAnalyse::removeBackground\fP (TH1 *histo, int const &niter=10, std::string const &fit_options='', std::string const &bidim_options='X') noexcept"
.br
.RI "Remove the background in the given histo\&. "
.ti -1c
.RI "void \fBremoveFits\fP (TH1 *histo)"
.br
.ti -1c
.RI "void \fBCoAnalyse::removeRandomBidim\fP (TH2 *matrix, int iterations=1, bool save_intermediate=false, ProjectionsBins projectionsY={{}}, ProjectionsBins projectionsX={{}})"
.br
.ti -1c
.RI "void \fBCoAnalyse::removeRandomY\fP (TH2 *matrix, int _stopX=\-1, int _stopY=\-1, bool writeIntermediate=false, ProjectionsBins projections={{}})"
.br
.RI "LEGACY\&. "
.ti -1c
.RI "void \fBresize_view_range\fP (TH1F *histo)"
.br
.ti -1c
.RI "void \fBresize_view_range\fP (TH1F *histo, float const &min)"
.br
.ti -1c
.RI "void \fBCoAnalyse::setX\fP (TH2 *matrix, TH1 *proj, int const &binX)"
.br
.RI "Set Y histogram proj in matrix at binX\&. "
.ti -1c
.RI "void \fBCoAnalyse::setY\fP (TH2 *matrix, TH1 *proj, int const &binY)"
.br
.RI "Set X histogram proj in matrix at binY\&. "
.ti -1c
.RI "void \fBshiftX\fP (TH1 *histo, double shift)"
.br
.RI "Shifts a histogram by 'shift' X value\&. "
.ti -1c
.RI "void \fBtest_alignator\fP (TTree *tree, int *NewIndex=nullptr, bool useNewIndex=false)"
.br
.ti -1c
.RI "bool \fBTHist_exists\fP (TH1 *histo)"
.br
.ti -1c
.RI "template<typename T , typename  = typename std::enable_if<std::is_arithmetic<T>::value>::type> ULong64_t \fBULong64_cast\fP (T const &t)"
.br
.RI "Casts a number into unsigned short\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "class \fBTypeRootMap\fP \fBtypeRootMap\fP"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBTH1F_map\fP =  std::map<std::string, TH1F*>"

.SS "using \fBunique_TFile\fP =  std::unique_ptr<TFile>"

.SS "using \fBunique_TH1F\fP =  std::unique_ptr<TH1F>"

.SS "using \fBunique_TH2F\fP =  std::unique_ptr<TH2F>"

.SS "using \fBunique_tree\fP =  std::unique_ptr<TTree>"

.SH "Function Documentation"
.PP 
.SS "void AddTH1 (TH1 * histo_total, TH1 * histo)"

.PP
Patch to the TH1::Add method when the histograms limits are inconsistent\&. 
.SS "bool AddTH1 (TH2 * histo2, TH1 * histo1, int index, bool x = \fCtrue\fP)"

.SS "bool AddTH1ByValue (TH2 * histo2, TH1 * histo1, int index, bool x = \fCtrue\fP)"

.PP
Like AddTH1 but adjusts the binning first\&. 
.PP
\fBTodo\fP
.RS 4
doesn't work for some reason \&.\&.\&.
.RE
.PP
.PP
\fBParameters\fP
.RS 4
\fIhisto2\fP 
.br
\fIhisto1\fP 
.br
\fIindex\fP 
.br
\fIx\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true 
.PP
false 
.RE
.PP

.SS "void alignator (TTree * tree, int * NewIndex)"

.SS "template<class T > std::map<std::string, T> create_map_of (TFile * file)"

.SS "template<class T > auto createBranch (TTree * tree, T * value, std::string const & name, int buffsize = \fC64000\fP)"

.PP
Create a branch for a given value and name\&. 
.SS "template<class T > auto createBranchArray (TTree * tree, T * array, std::string const & name, std::string const & name_size, int buffsize = \fC64000\fP)"

.PP
Create a branch for a given array and name\&. 
.PP
\fBParameters\fP
.RS 4
\fIname_size\fP The name of the leaf that holds the size of the array 
.RE
.PP

.SS "void draw_all_TH1 (std::string const & filename, int minX = \fC0\fP, int maxX = \fC0\fP, int rebin = \fC1\fP, std::string pattern = \fC''\fP)"

.PP
Draws all the TH1F of a given file one by one\&. 
.PP
\fBAttention\fP
.RS 4
Only works in CINT environnement (= macro only) 
.RE
.PP

.SS "int findNextBinAbove (TH1 * histo, int & bin, double threshold)"

.SS "int findNextBinBelow (TH1 * histo, int & bin, double threshold)"

.SS "void fuse_all_histo (std::string const & folder, std::string const & outRoot = \fC'fused_histo\&.root'\fP, bool const & bidim = \fCtrue\fP)"

.PP
allows one to fuse all the histograms with the same name from different files 
.SS "template<class T > std::vector<std::string> get_names_of (TFile * file)"

.SS "\fBTH1F_map\fP get_TH1F_map (TFile * file)"

.SS "\fBTH1F_map\fP get_TH1F_map (TFile * file, std::vector< std::string > & names)"

.SS "std::vector<std::string> get_TH1F_names (std::string const & filename)"

.SS "std::vector<std::string> get_TH1F_names (TFile * file)"

.SS "int getBin0 (TH1F * spectra)"

.PP
Get which bin holds the X = 0\&. 
.SS "void getData (TH1 * histo, std::vector< double > & data)"

.SS "void getData (TH1 * histo, std::vector< float > & data)"

.SS "bool getMeanPeak (TH1F * spectra, double & mean)"

.PP
Get the mean of the peak of a histogram with one nice single peak\&. 
.SS "void GetPoint (TVirtualPad * vpad, double & x, double & y)"

.PP
This method allows one to get the x and y values of where the user clicks on the graph\&. 
.SS "void libRoot ()"

.SS "template<typename T , typename  = typename std::enable_if<std::is_arithmetic<T>::value>::type> Long64_t Long64_cast (T const & t)\fC [inline]\fP"

.PP
Casts a number into unsigned short\&. 
.SS "float maxXaxis (TH1 * histo)"

.SS "float maxYaxis (TH1 * histo)"

.SS "double MeanBetweenEdges (TH1F * hist, double edge1, double edge2)"

.SS "float minXaxis (TH1 * histo)"

.SS "float minYaxis (TH1 * histo)"

.SS "std::ostream& operator<< (std::ostream & cout, \fBTHBinning\fP binning)"

.SS "std::ostream& operator<< (std::ostream & out, TTree * tree)"

.SS "void removeFits (TH1 * histo)"

.SS "void resize_view_range (TH1F * histo)"

.SS "void resize_view_range (TH1F * histo, float const & min)"

.SS "void shiftX (TH1 * histo, double shift)"

.PP
Shifts a histogram by 'shift' X value\&. 
.PP
\fBParameters\fP
.RS 4
\fIshift\fP Shifts each bin content by 'shift' units of the x axis 
.RE
.PP

.SS "void test_alignator (TTree * tree, int * NewIndex = \fCnullptr\fP, bool useNewIndex = \fCfalse\fP)"

.SS "bool THist_exists (TH1 * histo)"

.SS "template<typename T , typename  = typename std::enable_if<std::is_arithmetic<T>::value>::type> ULong64_t ULong64_cast (T const & t)\fC [inline]\fP"

.PP
Casts a number into unsigned short\&. 
.SH "Variable Documentation"
.PP 
.SS "class \fBTypeRootMap\fP typeRootMap"

.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
