.TH "Faster2Root" 3 "Mon Mar 25 2024" "Nuball2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Faster2Root \- Basic class to perform faster to root tree data conversion\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Faster2Root\&.hpp>\fP
.PP
Inherited by \fBMySimpleConvertor\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbuildEvents\fP (int time_window_ns)"
.br
.ti -1c
.RI "void \fBconvert\fP (std::string const &dataFolder, std::string const &outputFolder, int const &nb_files=\-1)"
.br
.ti -1c
.RI "\fBFaster2Root\fP ()"
.br
.ti -1c
.RI "\fBFaster2Root\fP (int argc, char **argv)"
.br
.ti -1c
.RI "\fBFaster2Root\fP (int argc, char **argv, \fBTriggerEvent\fP trigger)"
.br
.ti -1c
.RI "\fBFaster2Root\fP (\fBPath\fP const &inputFolder, \fBPath\fP const &outputFolder, int const &nb_files=\-1, bool const &\fBbuildEvents\fP=false)"
.br
.RI "Raw conversion : "
.ti -1c
.RI "void \fBloadCalibration\fP (std::string const &calibFile)"
.br
.ti -1c
.RI "void \fBloadTimeshifts\fP (std::string const &dTfile)"
.br
.ti -1c
.RI "void \fBloadTriggerFile\fP (std::string const &file)"
.br
.RI "Loads a trigger file\&. "
.ti -1c
.RI "void \fBoverwrite\fP (bool const &_overwrite)"
.br
.ti -1c
.RI "void \fBsetCalibration\fP (\fBCalibration\fP const &calibration)"
.br
.ti -1c
.RI "void \fBsetNbFiles\fP (int const &nb_files=\-1)"
.br
.ti -1c
.RI "void \fBsetNbThreads\fP (int const &nb_threads=\-1)"
.br
.ti -1c
.RI "void \fBsetTimeshifts\fP (\fBTimeshifts\fP const &timeshifts)"
.br
.ti -1c
.RI "void \fBsetTrigger\fP (\fBTriggerEvent\fP other)"
.br
.ti -1c
.RI "void \fBthrowSingles\fP (bool const &_throw_single=true)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBconvertFile\fP (\fBHit\fP &hit, \fBFasterReader\fP &reader, \fBPath\fP const &outPath)"
.br
.ti -1c
.RI "void \fBload\fP (int argc, char **argv)"
.br
.ti -1c
.RI "virtual void \fBprintParameters\fP () const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBdispatch_threads\fP (\fBHit\fP &hit, \fBFasterReader\fP &reader, \fBFaster2Root\fP &convertor, \fBPath\fP const &outPath)"
.br
.RI "Dispatch the \fBFaster2Root::convertFile()\fP method through the threads\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "bool \fBm_calibrate\fP = false"
.br
.ti -1c
.RI "\fBCalibration\fP \fBm_calibration\fP"
.br
.ti -1c
.RI "bool \fBm_eventbuilding\fP = false"
.br
.ti -1c
.RI "bool \fBm_loaded_trigger\fP = false"
.br
.ti -1c
.RI "int \fBm_nb_files\fP = \-1"
.br
.ti -1c
.RI "int \fBm_nb_threads\fP = 1"
.br
.ti -1c
.RI "bool \fBm_ok\fP = false"
.br
.ti -1c
.RI "bool \fBm_overwrite\fP = false"
.br
.ti -1c
.RI "bool \fBm_throw_single\fP = false"
.br
.ti -1c
.RI "Long64_t \fBm_time_window\fP = 1500000"
.br
.ti -1c
.RI "\fBTimeshifts\fP \fBm_timeshifts\fP"
.br
.ti -1c
.RI "\fBMTCounter\fP \fBm_total_events\fP"
.br
.ti -1c
.RI "\fBMTCounter\fP \fBm_total_hits\fP"
.br
.ti -1c
.RI "\fBTimer\fP \fBm_total_timer\fP"
.br
.ti -1c
.RI "\fBMTCounter\fP \fBm_trigg_events\fP"
.br
.ti -1c
.RI "\fBTriggerEvent\fP \fBm_trigger\fP = [](const \fBEvent\fP&) { return true; }"
.br
.ti -1c
.RI "std::string \fBm_trigger_file\fP"
.br
.ti -1c
.RI "std::vector< \fBLabel\fP > \fBm_triggering_labels\fP"
.br
.ti -1c
.RI "bool \fBm_use_RF\fP = false"
.br
.ti -1c
.RI "bool \fBm_use_trigger\fP = false"
.br
.in -1c
.SH "Detailed Description"
.PP 
Basic class to perform faster to root tree data conversion\&. 

Section 1 : Options
.PP
Use this class to perform raw conversion\&. Without any option, no calibration, no time alignement and no event building are performed\&. If you want to do more, you have to load the ID file with the -i option\&. This file has the following format :
.PP
label_nb_1 name label_nb_2 name \&.\&.\&. label_nb_3 name
.PP
You can build it from the index\&.pid file generated by faster
.PP
You can import a calibration file using -c option\&. Considering the equation E_cal = a + b*ADC + c*ADCÂ² \&.\&.\&., the file has the following structure :
.PP
label_nb a b (c) (d)
.PP
If a detector has no calibration data, then leaving its line empty will automatically setup a = 0 and b = 1\&. c and d are optional, they will be filled with 0 by default\&. You can choose the number of parameter line by line, because each detector may needs a different correction order\&.
.PP
Now, let's attack the most difficult part : timing and event building\&. So far, the data are still shuffled because of time shifts induced by faster hardware\&. So there are different options :
.PP
-e [time_window_ns] : Simple event building\&. If no time realignment, the time shift can be big so it is recommended to use a window of at least 1500 ns width\&. This option will always result in more time and memory consumption because the conversion is done in 3 step : First the hits are time aligned and put in a memory resident root tree\&. But the hits are still shuffled, because only their timestamp have been modified\&. Therefore, the second step results in realigned data\&. And finally the conversion to root using event building will take place with truly time aligned data\&.
.PP
-m [threads_number] : Multithreading\&. use this option to choose the number of files to treat in parallel\&.
.PP
-t [timeshift_file] : Load the timeshifts file\&.
.PP
Recap & ancillary parameters :
.PP
-c [calibration_file] : Load the calibration -e [time_window_ns] : Perform event building with time_window_ns = 1500 ns by default -i [ID_file] : Load ID file\&. For Nuball2 data, allows for nice lookup tables to know the type of detector like isDSSD[label] or isGe[label] -m [threads_number] : Choose the number of files to treat in parallel -n [files_number] : Choose the total number of files to treat inside a data folder -t [time_window_ns] : Loads timeshift data --throw_single : If you are not interested in single hits but only at coincidences with at least another detector --trigger [filename] : Loads a trigger file (look below)
.PP
\fBAttention\fP
.RS 4
The two first parameters must be /path/to/data/ and /path/to/output/ Example 1 : 
.PP
.nf
 Faster2Root("/path/to/data /path/to/output -i index_129.id -c calib.calib -e 200 -m 4 -t timeshifts.dT ")

.fi
.PP
 Example 2 :
.RE
.PP
We want to create a \fBDSSD\fP trigger in a Nuball2 experiment : 
.PP
.nf
int main(int argc, argv** argv)
{
  Faster2Root convertor(argc, argv, [](const Event& event)
  {
    for (int hit_i = 0; hit_i<event.mult; hit_i++)
    {
      auto const & label = event.labels[hit_i]]
      if (label>799 && label<856) return true;
    }
    return false;
  });
}

.fi
.PP
 Then compile the code and call : \&./executable /path/to/data /path/to/output -i index_129\&.list -c calib\&.calib -e 200 -m 4 -t timeshifts\&.dT
.PP
Section 2 : Format
.PP
The root tree is made of 6 leaves :
.PP
type name Description int mult Multiplicity : number of hits in the event unsigned short [] label Labels int/float [] ADC/nrj (ADC/QDC1) / Calibrated energy int/float [] QDC2/nrj2 QDC2 / Calibrated energy in QDC2 bool [] pileup Pileup/Saturation bit
.PP
The output will therefore depend on wether you calibrated the data or not
.PP
In the code, the main object handling the event data is \fBEvent\fP\&. You have to have a look at its complete description if you are to read the data 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Faster2Root::Faster2Root ()\fC [inline]\fP"

.SS "Faster2Root::Faster2Root (int argc, char ** argv)\fC [inline]\fP"

.SS "Faster2Root::Faster2Root (int argc, char ** argv, \fBTriggerEvent\fP trigger)\fC [inline]\fP"

.SS "Faster2Root::Faster2Root (\fBPath\fP const & inputFolder, \fBPath\fP const & outputFolder, int const & nb_files = \fC\-1\fP, bool const & buildEvents = \fCfalse\fP)\fC [inline]\fP"

.PP
Raw conversion : 
.PP
\fBDeprecated\fP
.RS 4

.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void Faster2Root::buildEvents (int time_window_ns)\fC [inline]\fP"

.SS "void Faster2Root::convert (std::string const & dataFolder, std::string const & outputFolder, int const & nb_files = \fC\-1\fP)"

.SS "void Faster2Root::convertFile (\fBHit\fP & hit, \fBFasterReader\fP & reader, \fBPath\fP const & outPath)\fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBParameters\fP
.RS 4
\fIhit\fP 
.br
\fIreader\fP 
.br
\fIoutPath\fP 
.RE
.PP

.PP
Reimplemented in \fBMySimpleConvertor\fP\&.
.SS "static void Faster2Root::dispatch_threads (\fBHit\fP & hit, \fBFasterReader\fP & reader, \fBFaster2Root\fP & convertor, \fBPath\fP const & outPath)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
Dispatch the \fBFaster2Root::convertFile()\fP method through the threads\&. 
.SS "void Faster2Root::load (int argc, char ** argv)\fC [protected]\fP"

.SS "void Faster2Root::loadCalibration (std::string const & calibFile)\fC [inline]\fP"

.SS "void Faster2Root::loadTimeshifts (std::string const & dTfile)\fC [inline]\fP"

.SS "void Faster2Root::loadTriggerFile (std::string const & filename)"

.PP
Loads a trigger file\&. A trigger file contains a list of the detectors's labels (the number, not the name) that are required in the event (e\&.g\&. a germanium trigger file would list all the labels of the germaniums)\&. If you want more specific trigger you have to create your own executable, include \fBFaster2Root\fP and follow the example 2 of the documentation of the class\&. 
.SS "void Faster2Root::overwrite (bool const & _overwrite)\fC [inline]\fP"

.SS "void Faster2Root::printParameters () const\fC [protected]\fP, \fC [virtual]\fP"

.SS "void Faster2Root::setCalibration (\fBCalibration\fP const & calibration)\fC [inline]\fP"

.SS "void Faster2Root::setNbFiles (int const & nb_files = \fC\-1\fP)\fC [inline]\fP"

.SS "void Faster2Root::setNbThreads (int const & nb_threads = \fC\-1\fP)\fC [inline]\fP"

.SS "void Faster2Root::setTimeshifts (\fBTimeshifts\fP const & timeshifts)\fC [inline]\fP"

.SS "void Faster2Root::setTrigger (\fBTriggerEvent\fP other)\fC [inline]\fP"

.SS "void Faster2Root::throwSingles (bool const & _throw_single = \fCtrue\fP)\fC [inline]\fP"

.SH "Member Data Documentation"
.PP 
.SS "bool Faster2Root::m_calibrate = false\fC [protected]\fP"

.SS "\fBCalibration\fP Faster2Root::m_calibration\fC [protected]\fP"

.SS "bool Faster2Root::m_eventbuilding = false\fC [protected]\fP"

.SS "bool Faster2Root::m_loaded_trigger = false\fC [protected]\fP"

.SS "int Faster2Root::m_nb_files = \-1\fC [protected]\fP"

.SS "int Faster2Root::m_nb_threads = 1\fC [protected]\fP"

.SS "bool Faster2Root::m_ok = false\fC [protected]\fP"

.SS "bool Faster2Root::m_overwrite = false\fC [protected]\fP"

.SS "bool Faster2Root::m_throw_single = false\fC [protected]\fP"

.SS "Long64_t Faster2Root::m_time_window = 1500000\fC [protected]\fP"

.SS "\fBTimeshifts\fP Faster2Root::m_timeshifts\fC [protected]\fP"

.SS "\fBMTCounter\fP Faster2Root::m_total_events\fC [protected]\fP"

.SS "\fBMTCounter\fP Faster2Root::m_total_hits\fC [protected]\fP"

.SS "\fBTimer\fP Faster2Root::m_total_timer\fC [protected]\fP"

.SS "\fBMTCounter\fP Faster2Root::m_trigg_events\fC [protected]\fP"

.SS "\fBTriggerEvent\fP Faster2Root::m_trigger = [](const \fBEvent\fP&) { return true; }\fC [protected]\fP"

.SS "std::string Faster2Root::m_trigger_file\fC [protected]\fP"

.SS "std::vector<\fBLabel\fP> Faster2Root::m_triggering_labels\fC [protected]\fP"

.SS "bool Faster2Root::m_use_RF = false\fC [protected]\fP"

.SS "bool Faster2Root::m_use_trigger = false\fC [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for Nuball2 from the source code\&.
